66Target Completion Date: 15-02-2025
Certification Link:  [Certified Kubernetes Application Developer (CKAD)](https://trainingportal.linuxfoundation.org/courses/certified-kubernetes-application-developer-ckad) 

**Who is it for?**  
This certification is for Kubernetes engineers, cloud engineers and other IT professionals responsible for building, deploying, and configuring cloud native applications with Kubernetes.

**What does this certification demonstrate?  
**The Certified Kubernetes Application Developer (CKAD) can design, build and deploy cloud-native applications for Kubernetes.  
A CKAD can define application resources and use Kubernetes core primitives to create/migrate, configure, expose and observe scalable applications.  
The exam assumes working knowledge of container runtimes and microservice architecture.

The successful candidate will be comfortable:  
– working with (OCI-compliant) container images  
– applying Cloud Native application concepts and architectures  
– working with and validating Kubernetes resource definitions

**What is included?  
**2 hour duration  
Performance Based Exam  
Certification valid for 2 years  
Includes 12 month eligibility  
Includes one retake  
PDF Certificate and Digital Badge  
Exam Simulator

**Application Design and Build (20%)  
**Define, build and modify container images  
Choose and use the right workload resource (Deployment, DaemonSet, CronJob, etc.)  
Understand multi-container Pod design patterns (e.g. sidecar, init and others)  
Utilize persistent and ephemeral volumes

**Application Deployment (20%)**  
Use Kubernetes primitives to implement common deployment strategies (e.g. blue/green or canary)  
Understand Deployments and how to perform rolling updates  
Use the Helm package manager to deploy existing packages  
Kustomize

**Application Observability and Maintenance (15%)  
** Understand API deprecations  
Implement probes and health checks  
Use built-in CLI tools to monitor Kubernetes applications  
Utilize container logs  
Debugging in Kubernetes

**Application Environment, Configuration and Security (25%)  
** Discover and use resources that extend Kubernetes (CRD, Operators)  
Understand authentication, authorization and admission control  
Understand Requests, limits, quotas  
Understand ConfigMaps  
Create & consume Secrets  
Understand ServiceAccounts  
Understand Application Security (SecurityContexts, Capabilities, etc.)

**Services and Networking (20%)  
** Demonstrate basic understanding of NetworkPolicies  
Provide and troubleshoot access to applications via services  
Use Ingress rules to expose applications

#### **Start by enrolling in these free courses**

- [Introduction to Cloud Infrastructure Technologies (LFS151)](https://trainingportal.linuxfoundation.org/courses/introduction-to-cloud-infrastructure-technologies?query=LFS151)
- [Introduction to Kubernetes (LFS158)](https://trainingportal.linuxfoundation.org/courses/introduction-to-kubernetes?query=LFS158)

#### **Then consider intermediate training:**

- [Containers Fundamentals (LFS253)](https://trainingportal.linuxfoundation.org/courses/containers-fundamentals-lfs253?query=LFS253)  
    
#### **Increase your chance of becoming certified on the first try by taking:**

- [Kubernetes for Developers (LFS259)](https://trainingportal.linuxfoundation.org/courses/kubernetes-for-developers-lfd259?query=LFD259) / Online, Self-Paced  
    OR
- [Kubernetes Administration (LFS459)](https://training.linuxfoundation.org/training/kubernetes-for-app-developers/) / Instructor-Led _(Link takes you to the public website to view available dates)_

#### **Finally, register and sit for your exam:**

- Certified Kubernetes Application Developer (CKAD) _(This certification)_

#### **After completing your CKAD, consider these additional topics:**

- [Introduction to Serverless on Kubernetes (LFS157)](https://trainingportal.linuxfoundation.org/courses/introduction-to-serverless-on-kubernetes-lfs157?query=LFs157)

[kubectl Quick Reference | Kubernetes](https://kubernetes.io/docs/reference/kubectl/quick-reference/)

#### CKAD Exam passing tips
120 mins - 66% passing
Open book exam

Effectively prepare for this exam
bash shell
copy paste ctrl+shift+c - copy
ctrl+shift+v - paster
allowed to use official document.
2 weeks preparing
2-3 days practicing with simulation
type a lot
k8s entities
pod
deploy
ingress
service
volume
networkpolicy
secret
configmap
pv
pvc
job
cronjob

Don't just memorize the answer focus on finding the answers
2 ways to do the same in the exam
using CLI commands and YAML files
Use --help with CLI commands
for yaml files learn how to leverage the documents copy the yaml file and modify it as per your needs 
Type no. 2 - Type effeciently to avoid typo error. use shortcuts and tab whereever possible.
some common shortcuts
k = kubectl
deploy = deployments
ns = namespace
sa=serviceaccount
svr = service
rs = replicaset
ep = endpoint
kubectl ap-resources to list all APIs and their abbrivations
some command parameters
```-n <namespace>
-o yaml
-l <label>
--dry-run=client
k get all -A
--show-labels
```

Tip 3:
How to find the documentation
Key exam concepts
B/G deployment.  Cananry deployment, rolback, update, try to do version update, roll back scale up, scale down
expose # how to expose in service layer
NetworkPolicy
Volume # how to manage volume
Secret/Configmap
PV/PVC
Job/Cronjob
Resource
Docker
Debugging - no more than 2 error, identify the problems, verify, 2-3 debigging questions, make changes in 1 or 2 errors.
Common debugging question topics
1. service account name issue
2. Label mismatch issue
3. target port doesn't match
4. name match issue
5. nodeport doesn't match
6. environment variable
7. service point to pod

use log to examine any port issue


**From another youtube video**
Docker image management 0 hello:1.2.3
OCI image export - build an image from docker file and exporting it in OCI format
memorize basic image tagging syntax - you will need to be fast

Study all possible cronjob configuration option
key areas to master  - 
concurrency policies, history limits, starting deadlines, where to find the cron syntax in the docs.

Resource management
- namespace level resource limits
- practice, setting and modifying, memory limit, cpu limit at pod and namespace level
Debugging network traffic
understand full flow of traffic from ingress to controller to a service, backend service and to the pod, and how the ports are being set.

Service account, roleback access control. - just change the namespace
know your secret and configmaps - 
know how to inject keys from secret, how to inject secrets.






# Application Design and Build

| Exam Objective                                 | Chapter                                                                                                                              | Reference Documentation                                                                                                                                                                                                                                     | Tutorial                                                                                                                                                                                                                                                                                                                      | Comments | Commands |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------- |
| Define, build, and modify container images     | [Chapter 4](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch04.html#containers)           | [Containers](https://oreil.ly/vXUWo)                                                                                                                                                                                                                        | N/A                                                                                                                                                                                                                                                                                                                           |          |          |
| Understand Jobs and CronJobs                   | [Chapter 6](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch06.html#jobs_cronjobs)        | [Job](https://oreil.ly/fIKQc), [CronJob](https://oreil.ly/IIL2R)                                                                                                                                                                                            | [Indexed Job for Parallel Processing with Static Work Assignment](https://oreil.ly/ytd_X), [Automatic Cleanup for Finished Jobs](https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/), [Running Automated Tasks with a CronJob](https://kubernetes.io/docs/tasks/job/automated-tasks-with-cron-jobs/) |          |          |
| Understand multi-container Pod design patterns | [Chapter 8](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch08.html#multi_container_pods) | [Init Containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/), [How Pods manage multiple containers](https://kubernetes.io/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers)                                      | N/A                                                                                                                                                                                                                                                                                                                           |          |          |
| Utilize persistent and ephemeral volumes       | [Chapter 7](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch07.html#volumes)              | [Ephemeral Volumes](https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/), [Persistent Volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/), [Storage Classes](https://kubernetes.io/docs/concepts/storage/storage-classes/) | N/A                                                                                                                                                                                                                                                                                                                           |          |          |

Start with VIM Setup
```vim
set expandtab
set tabstop=2
set shiftwidth=2
```

Setup the kubectl autocomplete environment
```bash
source <(kubecl completion bash) #set up autocomplete in bash into the current shell
echo "source <(kubectl completion bash)" >> ~/.bashrc #add autocompletion permanently to your bash shell

# Shorhand alias for kubectl which works with completiomn
alias k=kubectl
complete -o default -F __start_kubectl k                                    ```
## Define build and Modify container images
Container is a single unit of software which includes, runtime env and configurations, includes operating system, the application source code and its binaries, dependencies and other needed system tools. The goal is to decouple the runtime env from the application to avoid problems related to be able to work on a single machine.
Process of building an application into a container is called *containerization* The instrcutions are defined in a *container file*. These images are usally published to a container registy.
Public registries are 
1. dockerhub
2. quay - redhat registry, can be self hosted
3. gcr - google container registry
4. Github container registry
5. ECR - Elastic container registry provided by AWS
6. Harbor - CNCF provided registry


![[Pasted image 20251019132142.png]]

To create an image we need to write a dockerfile. Dockerfile is a plain text file and can reside in any directory.

eg. of creating a java based application using azul zulu jre distribution

``` Dockerfile
FROM azul/zulu-openjdk:21-jre
WORKDIR /app
COPY target/java-hello-world-0.0.1.jar java-hello-world.jar
ENTRYPOINT ["java", "-jar", "/app/java-hello-world.jar"]
EXPOSE 8080
```

1. Defines the base image
2. sets the working dir, any command like `RUN`, `CMD`, `ADD`, `COPY` and `ENTRYPOINT` will be executed in the working dir
3. copies the JAR containing the compiled executable
4. Set the command and arguments.
5. Document the network ports the container should listen on.

use minimal base images

Working dockerfile
```
# use a minimal base image
FROM node:14-alpine AS build

#set a working dir
WORKDIR /app

# copy package file and install dependecies
COPY package.json package-lock.json ./
RUN npm install

# copy the rest of the application
COPY . .

# build the app
RUN npm run build

# use a small image for runtime
FROM node:14-alpine

# set a non-root user
RUN addgroup app && adduser -S -G app app
USER app

# set working dir
WORKDIR /app


# Copy only the build artifcacts
COPY --from=build /app/build /app

# start the app
CMD ["npm", "start"]

```

**Create a dockerfile to deploy an apache http servers with a custom main page**
```
FROM docker.ip/http:2.4
RUN echo "Hello, World!" > /usr/local/apache2/htdocs/index.html
```

**Build the image**
```
podman build -t mysimplehttpserver:v1.0 .
```

**Layers in the images**
```
# List all images
podman images

#check the layers of the images
podman image tree localhost/simplehttpserver:v1.0 
```

**Run the image locally**
```
# command to run the container
podman run -d --name httpserver -p 8080:80 localhost/simplehttpserver:v1.0

# command to check the status of the running container
podman ps

# check the logs of the containers
podman logs httpserver

# check if the http server is running from the container or not
curl 0.0.0.0:80
```

**run command inside the container to print the index.html file**
`docker exec -it httpserver cat /usr/local/apache2/htdocs/index.html`

**tag the image with ip and port of a private local registry and then push the image to the registry**
```
# tag the image with your registry ip, so here i am pushing to the dockerhub
podman tag localhost/simplehttpserver:v1.0 docker.io/omps/simplehttpserver:v1.0

# docker images now have 2 tags images refrencing to the same image id.
$ podman images
REPOSITORY                       TAG         IMAGE ID      CREATED         SIZE
docker.io/omps/simplehttpserver  v1.0        e8d2cf2452a1  36 minutes ago  120 MB
localhost/simplehttpserver       v1.0        e8d2cf2452a1  36 minutes ago  120 MB

# push the container image to the dockerhub
podman push docker.io/omps/simplehttpserver
```

**remove the local image**
```
# remove the local image
podman rmi docker.io/omps/simplehttpserver:v1.0

# pull the image again from the dockerhub
podman pull docker.io/omps/simplehttpserver:v1.0

# create a container without starting it
podman create busybox

# check if the container is running
podman container ls -a
```

**export a container to output.tar file**
```
podman container ls -a #pick the container id here

# export the container
podman expoer <container id> --output=output.tar
```

**run a pod with image which is pushed into the registry**
```
kubectl run simpleapp --image=docker.io/omps/mysimpleapp:v1.0 --port-80

# check the app status using curl
curl $(kubectl get pods simpleapp -o jsonpath='{status.podIP}') ## I am not able to run this command so for [] 

```

**login to remote registry and the read the credentials from the default file**
```
# Login to dockerhub
podman login --username $DOCKER_USER --password $DOCKER_PASSW docker.io

cat $XDG_RUNTIME_DIR/containers/auth.json ## This files stores the auth files locally
```

**Create a secret from existing login credentials and from the CLI**
```
# Creating secret in kubectl using config.json file 
kubectl create secret generic mysecret --fromfile=.dockerconfigjson=$XDG_RUNTIME_DIR/containers/auth.json --type=kubernetes.io/

# creating secrent in kubernetes using kubectl using parameters at CLI
kubectl create secret docker-registry mysecret2 --docker-server=https://index.docker.io/v1/ --docker-username=$DOCKER_USER --docker-password=$DOCKER_PASS
```

**create a mainfest for a pod that uses one of the two secrests to pull an images hosted on the remote private registry**
```yaml
apiVersion: v1
kind: Pod
metadata:
	name: primavate-reg
spec:
	containers:
	- name: private-reg-container
	  image: $PRIVATE_IMG
	imagePullSecrets:
	- name: mysecret
```

**Clean up the images**

```kubectl 
### Commands
podman rmi --all --force
podman rm --all
kubectl delete pod http
kubectl delete pod simplehttpserver
kubectl delete -f private-reg.yaml
```



```
docker build -t <image name>:<path to dockerfile>
```
`-t` is for assigning tags
`<image name>`: assign name to your image
`<tag>`: version or identifies for the image
`<path-to-dockerfile>`: path which you plan to use for dockerfile
eg: `docker build -t myapp:v1.0 .`


## Choose the right workload
**Scenario 1: pick the right controller and deploy the app**
1. deploy a logging agent which collect logs from every nodes on the cluster which collect the logs and forward them to a central server - we will need daemonset.
2. we want one pod per node and which get deployed when a new node is created.

```daemonset.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: log-writer
spec:
  selector:
    matchLabels:
      name: log-writer
  template:
    metadata:
      labels:
        name: log-writer
	spec:
	  containers:
	  - name: logger
	    image: busybox
	    command: ["/bin/sh"]
	    args: ["-c", "while true: do echo $(date) writing logs...; sleep 5; done"]
```

```kubectl
# Commands
kubectl apply -f daemonset.yaml # apply and create daemonset on both the nodes
kubectl get daemonset # to check if the daemonset is running or not
kubectl get pods # check the status of the pods
kubectl logs log-writer-6ksbm # check the logs from one of the pods
```

**Scenario 2: Deploy a stateless web application** -
we need rolling-updates so we don't need daemonset here but deployments. 
here is the *deployment.yaml file for stateless application*

```deployment.yaml
apiVersion: app/v1
kind: Deployment
metadata:
  name: web-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nodeweb
template:
  metadata:
    labels:
      app: nodeweb
spec:
  containers:
  - name: nodeweb
    image: node-k8s-app:1.0
    ports:
    - containerPort: 3000
```

*Create a sevices.yaml file to expose the node port*
```yaml
# Services.yaml
apiVersion: v1
kind: Service
metadata:
	name: nodeweb-service
spec:
	selector:
		app: nodeweb
	ports:
	 - protocol: TCP
	   port: 80
	   targetPort: 3000
	type: NodePort: 
```

Check using 
```kubectl
kubectl apply -f deployment.yaml
kubectl apply -f services.yaml
kubectl get deployments # you should be able to see your deployment
kubectl get svc # you should be able to see your services and the nodeport its listening on
kubectl get pods # should be able to see 3 pods along with your other ports
curl NodePortIP:NodePortPort
```

**Scenario 3: How to clean up a temporary directory using a job like simple script - using cronjob yaml**

Create a cronjob yaml file to clean up the temporary directory every minute. and restart policy is only when there is a failure
```yaml
# Cronjob.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: temp-cleaner
spec:
  schedule: "*/1 * * * *" #run every minute
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: cleaner
            image: busybox
            command: ["/bin/sh", "-c"]
            args: ["echo cleaning up temp files at $(date)"]
          restartPolicy: OnFailure
```

## Design Multi container pods

Generaly used by sidecars and init containers, uses the same network, storage and ip.
Why sidecars - clean seperation of concerns
reusable infra components
Init containers: setup before main conatines.
	run once, before main container
	sequentioal execution
	do setup and then they exit
common use cases for init containers
	service check
	config fetch
	certificate validation
	wait for resources to come up
why to use?
	clean seperation of logic
	increaed relablitiy - by encapsulating setup
	better seperation for ops/devs
Other patterns: Adapter & Ambassadoes
	Adapter pattern
		transforms app output fro one format to another
		useful for log or data format conversion
		shares volume of the main container
	Ambassdor Pattern
		proxies traffic to external serices
		adds behaviour like retries or TLS
		app talks to localhost
		great of transparently adding behaviour like rate limiting retries or authentication
When to use
	can and don't want to modify the main container
	need to translate the log formats
	want to proxy or wrap behaviour

Use cases:
Scenario 1: Deploy a k8s pod which follows multi container pattern, use a init container, a main web server container and a sidecar container which tails the logs

We will start with building our index file, which we will place in our container and that container will be used for deploying on Kubernetes
```html
<!DOCTYPE html
<html>
<head>
<title>multi-container-app</title>
</head>
<body>
<h1>Hello from the mail web container</h1>
</body>
</html> 
```

Dockerfile for building the pod
```Dockerfile
FROM nginx:alpine
COPY index.html /usr/share/nginx/html/index.html
```

Create the image
`docker build -t ngninx-multicontainer-app:v1.0 .`

create the multicontainer pod
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-app
spec:
  volumes:
  - name: shared-logs
    emptyDir: {}
  initContainers:
  - name: init-startup
    image: busybox
    command: ['sh', '-c', 'echo "App starting up..." > /shared/startup.log']
    columeMounts:
    - name: shared-logs
      mountPath: /shared
      
containers:
  - name: nginx
    image: nginx-multicontainer-app:v1.0
    ports:
    - containerPort: 80
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/ngnix
  - name: log-tailer
    image: busybox
    command: ['sh', '-c', 'tail -n+1 -F /var/log/ngix/access.log']
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
```


## Use Volumes for storage
## Issues
1. Podman not able to login directly using podman login
While login using podman to dockerhub you need to specify the exact command as 
`podman login docker.io` this will allow podman to login to docker, all your push pull comannds should work, but you need to specify exact registry url while pulling the image
2. not able to get the images from dockerfile
While you can specify the full url in the image, at times when using someone elses dockerfile its not possible to specify the urll everytime. When you are using podman you need to make sure you have added the registry url in the podman registy.conf file
update the file: `/etc/containers/registries.conf`
add following line `unqualified-search-registries=["docker.io"]`
3. in the manifest, kubectl doesn't process variables. using variables withing the YAML will not be expanded by kubectl. any vairable in yaml file, kubectl will literally try to pull that off. in our case image - kubectl was literally pulling $PRIVATE_IMG there are 2 options to make this work
	1. Replace the full image name in the manifest with the real reference.
	2. inject the variable at the apply time.
		```
		export PRIVATE_IMG="docker.io/omps/simplehttpserver:v1.0
		envsubst '${PRIVATE_IMG}' < private-reg.yaml | kubectl apply -f
		```
4. While minikube as a single node is a very valid kubernetes cluster, using the same minikube for multiple node deployment may require us to start another minikube instance. While this is not straightforward, the approach is quite simple.
   
   In my situation I am running a podman desktop, while podman desktop does the heavy lifting, i used minikube within podman as my podman cluster.

	to spin up a new node in minikube simply run `minikube add node` thats it. This will create additional node for you in the minikube cluser, where you can try the daemonset.yaml

5. Even post deployment.yaml and services.yaml i was not able to access the deployment over web.
	I think this is some weired windows issue, which i was not able to understand through fully. I am running podman desktop on windows machine, accessing the kubernetes cluster using ubunutu 24.04 wsl the cluster is running a 2 node minikube. A simple solution for this is to forward the port to ensure i am able to access the web page

	 `kubectl port-forwards svc/nodeweb-service 8080:80`

6. . node-k8s-app is not available so we should be using https://hub.docker.com/r/instructorbryce/node-k8s-app in the deployment.yaml file

7. I am getting an error while create a image with podman and using the same image in my kubectl yaml file.
	I am using WSL termial with podman installed in WSL, while i am running the kuberenets cluster on podman desktop, i am not sure if this is the reason the desktop podman is not able to identify the images created on the wsl ubuntu machine. Yes this like common case for multiple environments. Now the question here is how to allow the ubunut podman images to be available on my minikube cluster, 1. simpler way to push it to dockerhub and pull the images from there.
	  
	
# Application Deployment

| Exam Objective                                                      | Chapter                                                                                                                                | Reference Documentation                                                                                                                                                                                                           | Tutorial                                                                                                                                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Use Kubernetes primitives to implement common deployment strategies | [Chapter 11](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch11.html#deployment_strategies) | [Deployment Spec Strategy](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy), [Canary Deployment](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments) | [Zero-downtime Deployment in Kubernetes with Jenkins](https://kubernetes.io/blog/2018/04/30/zero-downtime-deployment-kubernetes-jenkins/)                                                                                                                                                                                                                |
| Understand Deployments and how to perform rolling updates           | [Chapter 10](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch10.html#deployments)           | [Deployments](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/)                                                                                                                                              | [Using kubectl to Create a Deployment](https://kubernetes.io/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/), [Performing a Rolling Update](https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/), [Running Multiple Instances of Your App](https://kubernetes.io/docs/tutorials/kubernetes-basics/scale/scale-intro/) |
| Use the Helm package manager to deploy existing packages            | [Chapter 12](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch12.html#helm)                  | [Helm Project](https://helm.sh/docs/)                                                                                                                                                                                             | [Helm Charts: making it simple to package and deploy common applications on Kubernetes](https://kubernetes.io/blog/2016/10/helm-charts-making-it-simple-to-package-and-deploy-apps-on-kubernetes/)                                                                                                                                                       |

# Application Observability and Maintenance

|Exam Objective|Chapter|Reference Documentation|Tutorial|
|---|---|---|---|
|Understand API deprecations|[Chapter 13](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch13.html#api_deprecations)|[Kubernetes Deprecation Policy](https://kubernetes.io/docs/reference/using-api/deprecation-policy/), [Deprecated API Migration Guide](https://kubernetes.io/docs/reference/using-api/deprecation-guide/)|N/A|
|Implement probes and health checks|[Chapter 14](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch14.html#container_probes)|[Container probes](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)|[Configure Liveness, Readiness and Startup Probes](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)|
|Use provided tools to monitor Kubernetes applications|[Chapter 15](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch15.html#troubleshooting_pods_containers)|[Metrics Server Project](https://github.com/kubernetes-sigs/metrics-server)|[Metrics Server](https://kubernetes.io/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-server)|
|Utilize container logs|[Chapter 15](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch15.html#troubleshooting_pods_containers)|[Interacting with running Pods](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#interacting-with-running-pods)|[Examining Pod Logs](https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/#examine-pod-logs)|
|Debugging in Kubernetes|[Chapter 15](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch15.html#troubleshooting_pods_containers)|N/A|[Troubleshooting Applications](https://kubernetes.io/docs/tasks/debug/debug-application/), [Debug Running Pods](https://kubernetes.io/docs/tasks/debug/debug-application/debug-running-pod/), [Debug Pods](https://kubernetes.io/docs/tasks/debug/debug-application/debug-pods/), [Use Port Forwarding to Access Applications in a Cluster](https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/)|

# Application Environment, Configuration, and Security

|Exam Objective|Chapter|Reference Documentation|Tutorial|
|---|---|---|---|
|Discover and use resources that extend Kubernetes (CRD)|[Chapter 16](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch16.html#crds)|[Custom Resources](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/)|[Use Custom Resources](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/)|
|Understand authentication, authorization and admission control|[Chapter 17](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch17.html#authentication_authorization_admission_control)|[Controlling Access to the Kubernetes API](https://kubernetes.io/docs/concepts/security/controlling-access/), [Authenticating](https://kubernetes.io/docs/reference/access-authn-authz/authentication/), [Using RBAC Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/), [Admission Controllers Reference](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/)|N/A|
|Understand and defining resource requirements, limits and quotas|[Chapter 18](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch18.html#resource_requirements_limits_quotas)|[Resource Management for Pods and Containers](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/), [Limit Ranges](https://kubernetes.io/docs/concepts/policy/limit-range/), [Resource Quotas](https://kubernetes.io/docs/concepts/policy/resource-quotas/)|N/A|
|Understand ConfigMaps|[Chapter 19](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch19.html#configmaps_secrets)|[ConfigMaps](https://kubernetes.io/docs/concepts/configuration/configmap/)|[Configure a Pod to Use a ConfigMap](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/)|
|Create and consume Secrets|[Chapter 19](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch19.html#configmaps_secrets)|[Secrets](https://kubernetes.io/docs/concepts/configuration/secret/)|[Managing Secrets using kubectl](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/), [Managing Secrets using Configuration File](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)|
|Understand ServiceAccounts|[Chapter 17](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch17.html#authentication_authorization_admission_control)|[Service Accounts](https://kubernetes.io/docs/concepts/security/service-accounts/), [ServiceAccount permissions](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#service-account-permissions)|[Configure Service Accounts for Pods](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)|
|Understand SecurityContext|[Chapter 20](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch20.html#security_contexts)|N/A|[Configure a Security Context for a Pod or Container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/)|

# Services and Networking

|Exam Objective|Chapter|Reference Documentation|Tutorial|
|---|---|---|---|
|Demonstrate basic understanding of NetworkPolicies|[Chapter 23](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch23.html#network_policies)|[Network Policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/)|[Declare Network Policy](https://kubernetes.io/docs/tasks/administer-cluster/declare-network-policy/)|
|Provide and troubleshoot access to applications via services|[Chapter 21](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch21.html#services)|[Service](https://kubernetes.io/docs/concepts/services-networking/service/), [DNS for Services and Pods](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/)|[Connecting Applications with Services](https://kubernetes.io/docs/tutorials/services/connect-applications-service/), [Debug Services](https://kubernetes.io/docs/tasks/debug/debug-application/debug-service/)|
|Use Ingress rules to expose applications|[Chapter 22](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781098152857/ch22.html#ingresses)|[Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/), [Ingress Controllers](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)|[Set up Ingress on Minikube with the NGINX Ingress Controller](https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/)|

